<!DOCTYPE html>
<!-- saved from url=(0023)https://soap.spacie.me/ -->
<html lang="en" dir="ltr">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <title>Dual Snakes</title>
    <style media="screen">
        @import url('https://fonts.googleapis.com/css?family=Quicksand');

        * {
            font-family: 'Arial', sans-serif;
            /*box-sizing: border-box;*/
            margin-top: 10px;
            margin-bottom: 10px;
            margin-left: 5px;
            margin-right: 5px;
        }

        .app {
            display: inline-grid;
            text-align: left;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto;
            grid-row-gap: 0px;
            grid-template-areas: "edit edit" "canvas1 canvas2" "footer footer";
            padding:20px
        }

        .edit {
            grid-area: edit;
        }

        h1 {
            border-bottom: 1px solid #000;
            padding-bottom: 10px;
        }

        p, input {
            font-size: 20px;
        }

        input[type='range'] {
            width: 250px;
        }

        .canvas-title{
            color: #777777;
            font-size: 24px;
            font-weight: 900;
        }

        canvas {
            background: #eee;
            border-radius: 10px;
        }

        footer {
            grid-area: footer;
            color: #777777;
            text-align: center;
            font-size: 10px;
        }

        a {
            color: inherit;
        }
    </style>
    <!-- maths for the viz   -->
</head>
<body>

<div class="app">
    <div class="edit">
        <h1>Dual Snakes</h1>
        <p>Every point of the dual space is a straight line from the primal space. The dual of a curve is computed by connecting the tangents (straight lines) of this curve in the dual space. See what it looks like with different parametrizations of the dual space.</p>
        <p>Scale:
            <input type="range" value="2" min="1" max="10" step="0.01" id="scale">
        </p>
        <p>
            Dual Parametrization
            <input type="radio" id="y=ax-b" name="parametrization" value="y=ax-b" checked>
            <label for="y=ax-b">y=ax-b, Fenchel</label>
            <input type="radio" id="ax+by=1" name="parametrization" value="ax+by=1">
            <label for="ax+by=1">ax+by=1</label>
            <input type="radio" id="polar" name="parametrization" value="polar">
            <label for="polar">ax+by = a^2 + b^2, polar</label>
        </p>
        <p style="opacity: 0.5; font-size: 16px;">Remark: polar is not exactly a dual representation because its lines are not points in the primal.</p>
<!--  TODO add a checkbox to display sliding tangents and corresponding dual points
            plan: measure time elapsed since last refresh to decide on current segment
            for a given segment, draw tangent in appropriate color and highlight corresponding dual point
      TODO add a checkbox to display convex envelope and corresponding dual. Two kinds of envelope: full envelope and lower envelope.
-->
    </div>
    <div class="canvas-side" style="grid-area: canvas1; align-self: end;">
        <span class="canvas-title">Primal</span>
        <span style="opacity: 0.5; font-size: 16px">Use your mouse or finger to put some snakes on the plane</span>
        <br><canvas id="primal">Primal plane where you can draw any curvy snake.</canvas>
    </div>
    <div class="canvas-side" style="grid-area: canvas2; align-self: end;">
        <span class="canvas-title">Dual</span>
        <br><canvas id="dual">Dual plane where the dual snake will appear.</canvas>
    </div>
    <footer><p>
        Built by <a href="https://remilepriol.github.io/">Remi Le Priol</a> upon <a href="https://soap.spacie.me/">https://soap.spacie.me/</a>. <br>
        Feedback welcome at <code style="background-color: #777777; color: #FFFFFF"> remi dot lp dot 17 at gmail dot com </code>. <br>
        See also visualizations for the Legendre-Fenchel conjugate of a function at <a href="index.html">DualityViz</a>.
    </p></footer>
</div>


<script>

    function map(x, inMin, inMax, outMin, outMax) {
        return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin
    }

    let width = 600;

    const primalCanvas = document.getElementById("primal")
    const dualCanvas = document.getElementById("dual")
    for (let cvs of [primalCanvas, dualCanvas]) {
        cvs.width = cvs.height = width;
    }

    const primalContext = primalCanvas.getContext('2d')
    const dualContext = dualCanvas.getContext("2d")
    console.log(primalContext)

    let scale = 2
    document.querySelector('#scale').addEventListener('input', e => {
        // Parsing the input after forcing it to a string is a hack that seems to fix issues?
        scale = parseFloat(`${e.target.value}`)
    })

    let points = []
    let touching = false

    primalCanvas.addEventListener('touchstart', e => {
        e.preventDefault()
        if (e.target != primalCanvas) return
        points = []
        touching = true
    })

    primalCanvas.addEventListener('mousedown', e => {
        if (e.target != primalCanvas) return
        points = []
        touching = true
    })

    primalCanvas.addEventListener('touchmove', e => {
        e.preventDefault()
        if (e.target != primalCanvas) return
        let t = null
        for (const touch of e.touches) {
            if (touch.target == primalCanvas) t = touch
        }
        if (!touching || t == null) return
        const box = primalCanvas.getBoundingClientRect()
        const x = t.clientX - box.left
        const y = t.clientY - box.top
        points.push([map(x, 0, primalCanvas.width, -scale, scale), map(y, 0, primalCanvas.width, scale, -scale)])
    })

    primalCanvas.addEventListener('mousemove', e => {
        if (!touching) return
        const box = primalCanvas.getBoundingClientRect()
        const x = e.clientX - box.left
        const y = e.clientY - box.top
        points.push([map(x, 0, primalCanvas.width, -scale, scale), map(y, 0, primalCanvas.width, scale, -scale)])
    })

    primalCanvas.addEventListener('touchend', e => {
        e.preventDefault()
        if (e.target != primalCanvas) return
        touching = false
    })

    primalCanvas.addEventListener('mouseup', e => {
        if (e.target != primalCanvas) return
        touching = false
    })


    function render() {
        drawGrid(primalCanvas, primalContext, scale, "x","y");
        drawGrid(dualCanvas, dualContext, scale,"a","b");

        smoothPoints = smoothCurve(points);

        let parametrization = document.querySelector('input[name="parametrization"]:checked').value

        pp = [...smoothPoints]
        for (let i = 0; i < 1; i++) {
            // for i>=2 we see that the dual curve of the polar dual curve is not the primal curve.
            drawSnake(primalCanvas, primalContext, pp.reverse());
            pp = computeDualPoints(pp, parametrization);
            drawSnake(dualCanvas, dualContext, pp.reverse());
            pp = computeDualPoints(pp, parametrization);
        }

        window.requestAnimationFrame(render);
    }

    render()

    function smoothCurve(points) {
        // convolve points with some kernel
        let kernel = [.8, .6, .4, .2, .1];
        let sum = 1;
        for (let e of kernel) {
            sum += 2 * e;
        }

        let newPoints = [];
        for (let i = 0; i < points.length; i++) {
            let p = points[i].slice();
            for (let j = 0; j < kernel.length; j++) {
                for (let k = 0; k < 2; k++) {
                    p[k] += kernel[j] * (points[Math.max(0, i - j - 1)][k]
                        + points[Math.min(points.length - 1, i + j + 1)][k]);
                }
            }
            p[0] /= sum;
            p[1] /= sum;
            newPoints.push(p)
        }
        return newPoints
    }


    function computeDualPoints(points, transform = "y=ax-b") {
        let dualPoints = [];

        // get a representation for each segment of the primal line
        for (let i = 0; i < points.length - 1; i++) {
            let prev = points[i];
            let curr = points[i + 1];

            let distance = (curr[0] - prev[0]) ** 2 + (curr[1] - prev[1]) ** 2;
            if (distance < 1e-6) {
                if (dualPoints.length > 0) {
                    dualPoints.push(dualPoints[dualPoints.length - 1].slice())
                }
                continue;
            }

            let det = curr[1] * prev[0] - curr[0] * prev[1];
            let a, b;

            switch (transform) {
                case "fenchel":
                case "y=ax-b":
                    // Legendre transform
                    let slope = (curr[1] - prev[1]) / (curr[0] - prev[0]);
                    let intercept = curr[1] - slope * curr[0];

                    a = slope;
                    b = -intercept;
                    break;

                case "cramer":
                case "ax+by=1":
                    // Cramer formula
                    a = (curr[1] - prev[1]) / det;
                    b = -(curr[0] - prev[0]) / det;
                    break;

                case "polar":
                case "ax+by=a^2+b^2":
                    // X cos theta + Y sin theta = lambda
                    // shortest vector from (0,0) to the line
                    a = det * (curr[1] - prev[1]) / distance
                    b = -det * (curr[0] - prev[0]) / distance
                    break;
            }
            dualPoints.push([a, b]);

        }
        return dualPoints
    }

    function drawGrid(cvs, ctx, scale, xLabel, yLabel) {
        ctx.clearRect(0, 0, width, width)
        for (let x = 0; x < width / 2; x += (width / 2 / scale)) {
            ctx.lineWidth = 1
            ctx.strokeStyle = '#ccc'
            ctx.beginPath()
            ctx.moveTo(width / 2 + x, 0)
            ctx.lineTo(width / 2 + x, width)
            ctx.moveTo(width / 2 - x, 0)
            ctx.lineTo(width / 2 - x, width)
            ctx.moveTo(0, width / 2 + x)
            ctx.lineTo(width, width / 2 + x)
            ctx.moveTo(0, width / 2 - x)
            ctx.lineTo(width, width / 2 - x)
            ctx.stroke()
        }
        ctx.lineWidth = 2
        ctx.lineCap = 'round'
        ctx.strokeStyle = '#aaa'
        let arrowSize = 0.04;
        ctx.font = "30px Arial";
        ctx.fillStyle = "#666";
        ctx.beginPath()

        // horizontal line and arrow head
        ctx.moveTo(0, width / 2);
        ctx.lineTo(width, width / 2);
        ctx.lineTo((1-arrowSize)*width, (1-arrowSize)*width/2);
        ctx.moveTo(width, width / 2);
        ctx.lineTo((1-arrowSize)*width, (1+arrowSize)*width/2);
        ctx.fillText(xLabel, (1-arrowSize)*width - 20, (1+arrowSize)*width/2 + 10);

        // vertical line and arrow head
        ctx.moveTo(width / 2, 0)
        ctx.lineTo(width / 2, width);
        ctx.moveTo(width / 2, 0)
        ctx.lineTo((1-arrowSize)*width/2, arrowSize*width)
        ctx.moveTo(width / 2, 0)
        ctx.lineTo((1+arrowSize)*width/2, arrowSize*width)
        ctx.fillText(yLabel, (1-arrowSize)*width/2 - 20, (arrowSize)*width + 10);

        ctx.stroke()

        ctx.beginPath()
        ctx.arc(width / 2, cvs.height / 2, width / (scale * 2), 0, Math.PI * 2)
        ctx.stroke()
    }

    function drawSnake(cvs, ctx, snakePoints) {

        let tipCol = null

        // Draw the actual snake body
        for (let i = 1; i < snakePoints.length; i++) {
            let prev = snakePoints[i - 1]
            let curr = snakePoints[i]
            // TODO match color of the dual line with corresponding segment of the primal line
            ctx.strokeStyle = `hsl(${i / snakePoints.length * 360}, 60%, 55%)`
            ctx.lineWidth = Math.round(map(i - 1, 0, points.length, 15, 3))
            if (tipCol == null) tipCol = ctx.strokeStyle;
            ctx.beginPath()
            ctx.moveTo(map(prev[0], -scale, scale, 0, width), map(prev[1], scale, -scale, 0, width))
            ctx.lineTo(map(curr[0], -scale, scale, 0, width), map(curr[1], scale, -scale, 0, width))
            ctx.stroke()
        }

        // Draw eyes and stuff, yes it's long, no I don't know what I'm doing...
        if (snakePoints.length < 2) return
        let startPoint = snakePoints[0].map(x => map(x, -scale, scale, 0, width))
        let secondPoint = snakePoints[1].map(x => map(x, -scale, scale, 0, width))
        startPoint[1] = width - startPoint[1]
        secondPoint[1] = width - secondPoint[1]
        const dx = secondPoint[0] - startPoint[0]
        const dy = secondPoint[1] - startPoint[1]
        const ang = -Math.atan2(dy, dx)
        const tang = Math.atan2(dy, dx)
        ctx.lineWidth = 3
        ctx.strokeStyle = tipCol
        ctx.beginPath()
        let len = 15
        let tipX = startPoint[0] - Math.cos(tang) * len
        let tipY = startPoint[1] - Math.sin(tang) * len
        ctx.moveTo(startPoint[0], startPoint[1])
        ctx.lineTo(tipX, tipY)
        ctx.moveTo(tipX, tipY)
        ctx.lineTo(tipX - Math.cos(tang - 0.5) * len / 2, tipY - Math.sin(tang - 0.5) * len / 2)
        ctx.moveTo(tipX, tipY)
        ctx.lineTo(tipX - Math.cos(tang + 0.5) * len / 2, tipY - Math.sin(tang + 0.5) * len / 2)
        ctx.stroke()
        ctx.fillStyle = '#fff'
        ctx.beginPath()
        ctx.arc(startPoint[0] + Math.sin(ang) * 5, startPoint[1] + Math.cos(ang) * 4, 3, 0, Math.PI * 2)
        ctx.arc(startPoint[0] - Math.sin(ang) * 5, startPoint[1] - Math.cos(ang) * 4, 3, 0, Math.PI * 2)
        ctx.fill()
    }

</script>


</body>
</html>